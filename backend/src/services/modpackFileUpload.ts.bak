import { createHash } from 'crypto';
// import { readFile } from 'fs/promises'; // readFile seems unused
// import { basename, join } from 'path'; // basename, join seem unused
import JSZip from 'jszip';
import {
  ModpacksTable,
  ModpackVersionsTable,
  ModpackVersionFilesTable,
  ModpackVersionIndividualFilesTable
} from '../db/schema';
import { client as db } from '../db/client';
import { eq, and, desc, lt } from 'drizzle-orm';
import { v4 as uuidv4 } from 'uuid';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';

export enum FileType {
  MODS = 'mods',
  CONFIGS = 'configs',
  RESOURCES = 'resources'
}

interface FileInfo {
  path: string;
  hash: string;
  size: number;
}

interface UploadResult {
  versionFileId: number;
  isDelta: boolean;
  fileCount: number;
  totalSize: number;
  addedFiles: number;
  removedFiles: number;
  modifiedFiles: number;
}

interface ModpackManifest {
  name: string;
  version: string;
  mcVersion: string;
  forgeVersion?: string;
  files: {
    mods?: string;
    configs?: string; 
    resources?: string;
  };
  reusedFrom?: {
    mods?: string;
    configs?: string;
    resources?: string;
  };
}

export class ModpackFileUploadService {
  private s3Client: S3Client;
  private bucketName: string;

  constructor(region: string, bucketName: string, endpoint?: string) {
    this.bucketName = bucketName;
    
    this.s3Client = new S3Client({
      region,
      endpoint,
      forcePathStyle: true, // Necesario para algunos servicios compatibles con S3 como MinIO
      credentials: {
        accessKeyId: process.env.R2_ACCESS_KEY_ID || '',
        secretAccessKey: process.env.R2_SECRET_ACCESS_KEY || ''
      }
    });
  }

  /**
   * Calcula el hash SHA-256 de un buffer de datos
   */
  private calculateHash(data: Buffer): string {
    return createHash('sha256').update(data).digest('hex');
  }

  /**
   * Guarda un archivo en R2 Storage
   */
  private async saveFile(modpackId: string, versionId: string, fileType: FileType, fileBuffer: Buffer): Promise<string> {
    const hash = this.calculateHash(fileBuffer);
    const key = `${modpackId}/${versionId}/${fileType}/${hash}.zip`;
    
    // Guardamos el archivo en R2
    await this.s3Client.send(new PutObjectCommand({
      Bucket: this.bucketName,
      Key: key,
      Body: fileBuffer,
      ContentType: 'application/zip',
      Metadata: {
        'file-hash': hash,
        'file-type': fileType
      }
    }));
    
    return hash;
  }
  
  /**
   * Obtiene un archivo desde R2 Storage
   */
  private async getFile(key: string): Promise<Buffer> {
    const response = await this.s3Client.send(new GetObjectCommand({
      Bucket: this.bucketName,
      Key: key
    }));
    
    // Convertir el stream de respuesta a Buffer
    const chunks: Buffer[] = [];
    for await (const chunk of response.Body as any) {
      chunks.push(Buffer.from(chunk));
    }
    
    return Buffer.concat(chunks);
  }

  /**
   * Extrae información de los archivos individuales dentro del ZIP
   */
  private async extractFileInfo(zipBuffer: Buffer): Promise<FileInfo[]> {
    const zip = await JSZip.loadAsync(zipBuffer);
    const fileInfos: FileInfo[] = [];

    // Recorremos todos los archivos en el ZIP
    for (const [path, file] of Object.entries(zip.files)) {
      if (!file.dir) {  // Ignoramos directorios
        const content = await file.async('nodebuffer');
        fileInfos.push({
          path: path,
          hash: this.calculateHash(content),
          size: content.length
        });
      }
    }

    return fileInfos;
  }

  /**
   * Busca la última versión publicada del modpack para comparar
   */
  private async findPreviousVersionFile(modpackId: string, fileType: FileType): Promise<{ 
    versionFileId: number, 
    individualFiles: Record<string, { hash: string, size: number, id: number }> 
  } | null> {
    // Buscamos la última versión del modpack
    const latestVersions = await db
      .select()
      .from(ModpackVersionsTable)
      .where(eq(ModpackVersionsTable.modpackId, modpackId))
      .orderBy(desc(ModpackVersionsTable.releaseDate))
      .limit(1);

    if (latestVersions.length === 0) {
      return null; // No hay versiones previas
    }

    const latestVersionId = latestVersions[0].id;

    // Buscamos el archivo de tipo específico de esta versión
    const versionFiles = await db
      .select()
      .from(ModpackVersionFilesTable)
      .where(
        and(
          eq(ModpackVersionFilesTable.modpackVersionId, latestVersionId),
          eq(ModpackVersionFilesTable.type, fileType)
        )
      );

    if (versionFiles.length === 0) {
      return null; // No hay archivos de este tipo en la versión anterior
    }

    const versionFileId = versionFiles[0].id;

    // Obtenemos todos los archivos individuales
    const individualFiles = await db
      .select()
      .from(ModpackVersionIndividualFilesTable)
      .where(eq(ModpackVersionIndividualFilesTable.modpackVersionFileId, versionFileId));

    // Creamos un mapa para acceso rápido
    const fileMap: Record<string, { hash: string, size: number, id: number }> = {};
    for (const file of individualFiles) {
      fileMap[file.path] = {
        hash: file.hash,
        size: file.size || 0,
        id: file.id
      };
    }

    return {
      versionFileId,
      individualFiles: fileMap
    };
  }

  /**
   * Sube un archivo ZIP al modpack y procesa sus contenidos
   */
  public async uploadFile(
    userId: string,
    modpackId: string,
    modpackVersionId: string,
    fileType: FileType,
    fileBuffer: Buffer,
    reuseFromVersion?: string
  ): Promise<UploadResult> {
    // Verificar que el modpack existe
    const modpack = await db
      .select()
      .from(ModpacksTable)
      .where(eq(ModpacksTable.id, modpackId))
      .limit(1);

    if (modpack.length === 0) {
      throw new Error(`Modpack con ID ${modpackId} no encontrado`);
    }

    // Verificar que la versión existe y pertenece al modpack
    const modpackVersion = await db
      .select()
      .from(ModpackVersionsTable)
      .where(
        and(
          eq(ModpackVersionsTable.id, modpackVersionId),
          eq(ModpackVersionsTable.modpackId, modpackId)
        )
      )
      .limit(1);

    if (modpackVersion.length === 0) {
      throw new Error(`Versión con ID ${modpackVersionId} no encontrada para el modpack ${modpackId}`);
    }

    // Si se solicitó reutilizar archivos de otra versión y el tipo es compatible
    if (reuseFromVersion && (fileType === FileType.CONFIGS || fileType === FileType.RESOURCES)) {
      try {
        // Verificar que la versión a reutilizar existe
        const reusedVersion = await db
          .select()
          .from(ModpackVersionsTable)
          .where(
            and(
              eq(ModpackVersionsTable.id, reuseFromVersion),
              eq(ModpackVersionsTable.modpackId, modpackId)
            )
          )
          .limit(1);
          
        if (reusedVersion.length > 0) {
          // Buscar archivo del mismo tipo en la versión a reutilizar
          const reusedFiles = await db
            .select()
            .from(ModpackVersionFilesTable)
            .where(
              and(
                eq(ModpackVersionFilesTable.modpackVersionId, reuseFromVersion),
                eq(ModpackVersionFilesTable.type, fileType)
              )
            )
            .limit(1);
            
          if (reusedFiles.length > 0) {
            const reusedFileId = reusedFiles[0].id;
            
            // Copiar referencia del archivo en vez de subir uno nuevo
            const [versionFile] = await db
              .insert(ModpackVersionFilesTable)
              .values({
                modpackVersionId: modpackVersionId,
                type: fileType,
                hash: reusedFiles[0].hash,
                isDelta: reusedFiles[0].isDelta,
              })
              .returning({ id: ModpackVersionFilesTable.id });
              
            // Copiar referencias de archivos individuales
            const individualFiles = await db
              .select()
              .from(ModpackVersionIndividualFilesTable)
              .where(eq(ModpackVersionIndividualFilesTable.modpackVersionFileId, reusedFileId));
              
            // Copiar cada archivo individual
            for (const file of individualFiles) {
              await db
                .insert(ModpackVersionIndividualFilesTable)
                .values({
                  modpackVersionFileId: versionFile.id,
                  path: file.path,
                  hash: file.hash,
                  size: file.size,
                });
            }
            
            // Actualizar el manifest para indicar la reutilización
            await this.updateVersionManifest(modpackId, modpackVersionId, fileType, reusedFiles[0].hash, true, reuseFromVersion);
            
            const totalSize = individualFiles.reduce((sum, file) => sum + (file.size || 0), 0);
            
            return {
              versionFileId: versionFile.id,
              isDelta: reusedFiles[0].isDelta,
              fileCount: individualFiles.length,
              totalSize,
              addedFiles: 0,
              removedFiles: 0,
              modifiedFiles: 0,
              
            };
          }
        }
      } catch (error) {
        console.error('Error al reutilizar archivos:', error);
        // Continuamos con la subida normal si hubo un error
      }
    }

    // Guardar el archivo ZIP en R2
    const fileHash = await this.saveFile(modpackId, modpackVersionId, fileType, fileBuffer);
    
    // Extraer información de los archivos dentro del ZIP
    const newFiles = await this.extractFileInfo(fileBuffer);
    
    // Buscar versión anterior para comparación
    const previousVersion = await this.findPreviousVersionFile(modpackId, fileType);
    
    // Determinar si es un delta y qué archivos cambiaron
    let isDelta = false;
    let addedFiles = 0;
    let removedFiles = 0;
    let modifiedFiles = 0;
    
    if (previousVersion) {
      isDelta = true;
      
      // Comprobamos archivos añadidos o modificados
      for (const file of newFiles) {
        const prevFile = previousVersion.individualFiles[file.path];
        if (!prevFile) {
          addedFiles++;
        } else if (prevFile.hash !== file.hash) {
          modifiedFiles++;
        }
      }
      
      // Comprobamos archivos eliminados
      const newFilePaths = new Set(newFiles.map(f => f.path));
      for (const path in previousVersion.individualFiles) {
        if (!newFilePaths.has(path)) {
          removedFiles++;
        }
      }
    }
    
    // Insertar registro en la tabla de archivos de versión
    const [versionFile] = await db
      .insert(ModpackVersionFilesTable)
      .values({
        modpackVersionId: modpackVersionId,
        type: fileType,
        hash: fileHash,
        isDelta,
      })
      .returning({ id: ModpackVersionFilesTable.id });
    
    const versionFileId = versionFile.id;
    
    // Guardar archivos individuales en R2 y en la base de datos
    for (const file of newFiles) {
      // Extraer el archivo del ZIP
      const zip = await JSZip.loadAsync(fileBuffer);
      const fileContent = await zip.file(file.path)?.async('nodebuffer');
      
      if (fileContent) {
        // Guardar el archivo individual en R2
        const individualKey = `${modpackId}/${modpackVersionId}/${fileType}/individual/${file.hash}`;
        await this.s3Client.send(new PutObjectCommand({
          Bucket: this.bucketName,
          Key: individualKey,
          Body: fileContent,
          ContentType: 'application/octet-stream',
          Metadata: {
            'file-hash': file.hash,
            'original-path': file.path
          }
        }));
      }
      
      // Registrar en la base de datos
      await db
        .insert(ModpackVersionIndividualFilesTable)
        .values({
          modpackVersionFileId: versionFileId,
          path: file.path,
          hash: file.hash,
          size: file.size,
        });
    }
    
    // Actualizar el manifiesto de la versión
    await this.updateVersionManifest(modpackId, modpackVersionId, fileType, fileHash);
    
    // Calcular el tamaño total
    const totalSize = newFiles.reduce((sum, file) => sum + file.size, 0);
    
    return {
      versionFileId,
      isDelta,
      fileCount: newFiles.length,
      totalSize,
      addedFiles,
      removedFiles,
      modifiedFiles,
    };
  }
  
  /**
   * Actualiza o crea el manifiesto de una versión de modpack
   */
  private async updateVersionManifest(
    modpackId: string, 
    versionId: string, 
    fileType: FileType, 
    fileHash: string,
    isReused = false,
    reusedFromVersionId?: string
  ): Promise<void> {
    // Obtener información de la versión
    const version = await db
      .select()
      .from(ModpackVersionsTable)
      .where(eq(ModpackVersionsTable.id, versionId))
      .limit(1);
      
    if (version.length === 0) {
      throw new Error(`Versión no encontrada: ${versionId}`);
    }
    
    // Obtener información del modpack
    const modpack = await db
      .select()
      .from(ModpacksTable)
      .where(eq(ModpacksTable.id, modpackId))
      .limit(1);
      
    if (modpack.length === 0) {
      throw new Error(`Modpack no encontrado: ${modpackId}`);
    }
    
    // Intentar obtener el manifiesto existente
    let manifest: ModpackManifest;
    const manifestKey = `${modpackId}/${versionId}/manifest.json`;
    
    try {
      const existingManifest = await this.getFile(manifestKey);
      manifest = JSON.parse(existingManifest.toString('utf-8'));
    } catch (error) {
      // Si no existe, crear uno nuevo
      manifest = {
        name: modpack[0].name,
        version: version[0].version,
        mcVersion: version[0].mcVersion,
        forgeVersion: version[0].forgeVersion,
        files: {},
        reusedFrom: {}
      };
    }
    
    // Actualizar la parte correspondiente al tipo de archivo
    manifest.files[fileType] = fileHash;
    
    // Si se reutilizó de otra versión, guardar esa información
    if (isReused && reusedFromVersionId) {
      if (!manifest.reusedFrom) {
        manifest.reusedFrom = {};
      }
      manifest.reusedFrom[fileType] = reusedFromVersionId;
    }
    
    // Guardar el manifiesto actualizado
    await this.s3Client.send(new PutObjectCommand({
      Bucket: this.bucketName,
      Key: manifestKey,
      Body: JSON.stringify(manifest, null, 2),
      ContentType: 'application/json'
    }));
  }
  
  /**
   * Obtiene el manifiesto de una versión
   */
  public async getVersionManifest(modpackId: string, versionId: string): Promise<ModpackManifest | null> {
    // TODO: Implement getVersionManifest method
    return null;
  }

  /**
   * Reconstruye un archivo delta combinando con la versión anterior
   */
  public async reconstructDelta(modpackId: string, versionFileId: number): Promise<Buffer> {
    // Obtener información del archivo de versión
    const versionFile = await db
      .select()
      .from(ModpackVersionFilesTable)
      .where(eq(ModpackVersionFilesTable.id, versionFileId))
      .limit(1);

    if (versionFile.length === 0 || !versionFile[0].isDelta) {
      throw new Error(`Archivo de versión ${versionFileId} no encontrado o no es un delta`);
    }

    const currentVersionFile = versionFile[0];
    
    // Obtener la versión del modpack
    const modpackVersion = await db
      .select()
      .from(ModpackVersionsTable)
      .where(eq(ModpackVersionsTable.id, currentVersionFile.modpackVersionId))
      .limit(1);

    if (modpackVersion.length === 0) {
      throw new Error(`Versión del modpack no encontrada`);
    }
    
    // Buscar versiones anteriores para reconstruir el delta
    const previousVersions = await db
      .select()
      .from(ModpackVersionsTable)
      .where(
        and(
          eq(ModpackVersionsTable.modpackId, modpackId),
            lt(ModpackVersionsTable.releaseDate, modpackVersion[0].releaseDate),
        )
      )
      .orderBy(desc(ModpackVersionsTable.releaseDate))

    // Si no hay versiones anteriores, no podemos reconstruir
    if (previousVersions.length === 0) {
      throw new Error(`No hay versiones anteriores para reconstruir el delta`);
    }

    // Buscar el archivo de la misma categoría en la versión anterior
    const previousVersionFiles = await db
      .select()
      .from(ModpackVersionFilesTable)
      .where(
        and(
          eq(ModpackVersionFilesTable.modpackVersionId, previousVersions[0].id),
          eq(ModpackVersionFilesTable.type, currentVersionFile.type)
        )
      );

    if (previousVersionFiles.length === 0) {
      throw new Error(`No se encontró un archivo del mismo tipo en la versión anterior`);
    }
    
    const previousVersionFileId = previousVersionFiles[0].id;

    // Obtener archivos individuales de la versión actual
    const currentFiles = await db
      .select()
      .from(ModpackVersionIndividualFilesTable)
      .where(eq(ModpackVersionIndividualFilesTable.modpackVersionFileId, versionFileId));
    
    // Obtener archivos individuales de la versión anterior
    const previousFiles = await db
      .select()
      .from(ModpackVersionIndividualFilesTable)
      .where(eq(ModpackVersionIndividualFilesTable.modpackVersionFileId, previousVersionFileId));
    
    // Crear un mapa de los archivos previos para acceso rápido
    const prevFilesMap = new Map(previousFiles.map(f => [f.path, f]));
    
    // Crear un nuevo ZIP con los archivos combinados
    const zip = new JSZip();
    
    // Descargar y añadir archivos actuales desde R2
    for (const file of currentFiles) {
      try {
        // Construir la clave para R2 donde estaría el archivo individual
        const key = `${modpackId}/${modpackVersion[0].id}/${currentVersionFile.type}/individual/${file.hash}`;
        const content = await this.getFile(key);
        zip.file(file.path, content);
      } catch (err) {
        console.error(`Error al obtener el archivo individual:`, err);
        
        // Intentamos extraerlo del ZIP completo (opcional)
        try {
          const zipKey = `${modpackId}/${modpackVersion[0].id}/${currentVersionFile.type}/${currentVersionFile.hash}.zip`;
          const zipContent = await this.getFile(zipKey);
          const originalZip = await JSZip.loadAsync(zipContent);
          
          // Buscar el archivo por su ruta relativa
          const fileContent = await originalZip.file(file.path)?.async('nodebuffer');
          if (fileContent) {
            zip.file(file.path, fileContent);
          }
        } catch (zipErr) {
          console.error(`Error al extraer del ZIP original:`, zipErr);
        }
      }
    }
    
    // Añadir archivos de la versión anterior que no están en la actual
    for (const prevFile of previousFiles) {
      // Si el archivo no existe en la versión actual, lo añadimos
      if (!currentFiles.some(f => f.path === prevFile.path)) {
        try {
          const key = `${modpackId}/${previousVersions[0].id}/${currentVersionFile.type}/individual/${prevFile.hash}`;
          const content = await this.getFile(key);
          zip.file(prevFile.path, content);
        } catch (err) {
          console.error(`Error al obtener archivo anterior:`, err);
          
          // Intentamos extraerlo del ZIP completo de la versión anterior
          try {
            const zipKey = `${modpackId}/${previousVersions[0].id}/${currentVersionFile.type}/${previousVersionFiles[0].hash}.zip`;
            const zipContent = await this.getFile(zipKey);
            const originalZip = await JSZip.loadAsync(zipContent);
            
            const fileContent = await originalZip.file(prevFile.path)?.async('nodebuffer');
            if (fileContent) {
              zip.file(prevFile.path, fileContent);
            }
          } catch (zipErr) {
            console.error(`Error al extraer del ZIP anterior:`, zipErr);
          }
        }
      }
    }
    
    // Generar el ZIP final
    return await zip.generateAsync({ type: 'nodebuffer' });
  }

  /**
   * Verifica si un usuario tiene permiso para subir archivos al modpack
   */
  public async checkUploadPermission(userId: string, modpackId: string): Promise<boolean> {
    // Esta función verificaría los permisos en las tablas PublisherMembersTable y ModpackPermissionsTable
    // Por simplicidad, retornamos true en este ejemplo
    return true;
  }
}

// TODO: Replace console.log with a dedicated logger solution throughout the service.
// TODO: Implement robust authorization checks for all operations (e.g., checkUploadPermission).
// TODO: Consider using custom error classes for better error handling and propagation.


  private getMainFileS3Key(modpackId: string, versionId: string, fileType: FileType, fileHash: string): string {
    return `${modpackId}/${versionId}/${fileType}/${fileHash}.zip`;
  }

  /**
   * Generates the S3 key for an individual file extracted from a ZIP.
   */
  private getIndividualFileS3Key(modpackId: string, versionId: string, fileType: FileType, individualFileHash: string): string {
    return `${modpackId}/${versionId}/${fileType}/individual/${individualFileHash}`;
  }


  /**
   * Obtiene un archivo desde R2 Storage
   */
  private async getFile(key: string): Promise<Buffer> {
    try {
        const response = await this.s3Client.send(new GetObjectCommand({
            Bucket: this.bucketName,
            Key: key
        }));

        const chunks: Buffer[] = [];
        // Assuming response.Body is a ReadableStream (Node.js) or similar async iterable
        if (response.Body) {
            for await (const chunk of response.Body as any) {
                chunks.push(Buffer.from(chunk));
            }
        } else {
            throw new Error("S3 GetObjectCommand response body is empty.");
        }
        return Buffer.concat(chunks);
    } catch (error: any) {
        console.error(`[SERVICE_MODPACK_UPLOAD] Failed to get file from S3 at key ${key}:`, error);
        throw new Error(`Failed to retrieve file from storage (key: ${key}): ${error.message}`);
    }
  }

  /**
   * Extrae información de los archivos individuales dentro del ZIP
   */
  private async extractFileInfoFromZip(zipBuffer: Buffer): Promise<FileInfo[]> {
    const zip = await JSZip.loadAsync(zipBuffer);
    const fileInfos: FileInfo[] = [];

    for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
      if (!zipEntry.dir) {
        const content = await zipEntry.async('nodebuffer');
        fileInfos.push({
          path: relativePath, // JSZip uses relative paths
          hash: this.calculateHash(content),
          size: content.length
        });
      }
    }
    return fileInfos;
  }

  private async _ensureModpackAndVersionExist(modpackId: string, modpackVersionId: string): Promise<{modpack: Modpack, version: ModpackVersion}> {
    const modpackRecord = await db.query.ModpacksTable.findFirst({ where: eq(ModpacksTable.id, modpackId) });
    if (!modpackRecord) throw new Error(`Modpack con ID ${modpackId} no encontrado`);

    const versionRecord = await db.query.ModpackVersionsTable.findFirst({
        where: and(eq(ModpackVersionsTable.id, modpackVersionId), eq(ModpackVersionsTable.modpackId, modpackId))
    });
    if (!versionRecord) throw new Error(`Versión con ID ${modpackVersionId} no encontrada para el modpack ${modpackId}`);

    return { modpack: new Modpack(modpackRecord), version: new ModpackVersion(versionRecord) };
  }

  private async _handleFileReuse(
    modpackId: string,
    currentModpackVersionId: string,
    fileType: FileType,
    reuseFromVersionId: string
  ): Promise<UploadResult | null> {
    console.log(`[SERVICE_MODPACK_UPLOAD] Attempting to reuse ${fileType} file from version ${reuseFromVersionId} for version ${currentModpackVersionId}`);
    const reusedVersion = await db.query.ModpackVersionsTable.findFirst({
        where: and(eq(ModpackVersionsTable.id, reuseFromVersionId), eq(ModpackVersionsTable.modpackId, modpackId))
    });
    if (!reusedVersion) {
        console.warn(`[SERVICE_MODPACK_UPLOAD] Version to reuse (ID: ${reuseFromVersionId}) not found for modpack ${modpackId}. Proceeding with new file upload.`);
        return null;
    }

    const reusedVersionFileRecord = await db.query.ModpackVersionFilesTable.findFirst({
        where: and(
            eq(ModpackVersionFilesTable.modpackVersionId, reuseFromVersionId),
            eq(ModpackVersionFilesTable.type, fileType)
        )
    });

    if (!reusedVersionFileRecord) {
        console.warn(`[SERVICE_MODPACK_UPLOAD] No ${fileType} file found in version ${reuseFromVersionId} to reuse. Proceeding with new file upload.`);
        return null;
    }

    // Start transaction for DB operations
    return await db.transaction(async (tx) => {
        const [newVersionFileEntry] = await tx
            .insert(ModpackVersionFilesTable)
            .values({
                modpackVersionId: currentModpackVersionId,
                type: fileType,
                hash: reusedVersionFileRecord.hash, // Reuse hash of the main ZIP
                isDelta: reusedVersionFileRecord.isDelta, // Reuse delta status
                size: reusedVersionFileRecord.size, // Reuse size of the main ZIP
            })
            .returning();

        const individualFilesToCopy = await tx.query.ModpackVersionIndividualFilesTable.findMany({
            where: eq(ModpackVersionIndividualFilesTable.modpackVersionFileId, reusedVersionFileRecord.id)
        });

        if (individualFilesToCopy.length > 0) {
            const newIndividualFilesValues = individualFilesToCopy.map(f => ({
                modpackVersionFileId: newVersionFileEntry.id,
                path: f.path,
                hash: f.hash,
                size: f.size,
            }));
            await tx.insert(ModpackVersionIndividualFilesTable).values(newIndividualFilesValues);
        }

        await this._updateVersionManifestInternal(
            modpackId, currentModpackVersionId, fileType, reusedVersionFileRecord.hash,
            tx, true, reuseFromVersionId
        );

        const totalSize = individualFilesToCopy.reduce((sum, file) => sum + (file.size || 0), 0);
        console.log(`[SERVICE_MODPACK_UPLOAD] Successfully reused ${fileType} from version ${reuseFromVersionId} for ${currentModpackVersionId}.`);
        return {
            versionFileId: newVersionFileEntry.id,
            isDelta: reusedVersionFileRecord.isDelta || false,
            fileCount: individualFilesToCopy.length,
            totalSize,
            addedFiles: 0, removedFiles: 0, modifiedFiles: 0, // No changes as it's a reuse
        };
    });
  }

  private async _processAndStoreNewFile(
    modpackId: string,
    modpackVersionId: string,
    fileType: FileType,
    fileBuffer: Buffer,
    modpackInfo: { name: string }, // Pass necessary info to avoid re-fetching
    versionInfo: { version: string, mcVersion: string, forgeVersion?: string | null },
    previousVersionData: Awaited<ReturnType<typeof this.findPreviousVersionFile>> // Use helper type
  ): Promise<UploadResult> {
    const mainFileHash = this.calculateHash(fileBuffer);
    const mainFileS3Key = this.getMainFileS3Key(modpackId, modpackVersionId, fileType, mainFileHash);

    console.log(`[SERVICE_MODPACK_UPLOAD] Saving main ${fileType} ZIP to S3: ${mainFileS3Key}`);
    await this.saveFileToStorage(mainFileS3Key, fileBuffer, 'application/zip', {
        'file-hash': mainFileHash, 'file-type': fileType
    });

    console.log(`[SERVICE_MODPACK_UPLOAD] Extracting file info from ${fileType} ZIP.`);
    const newIndividualFileInfos = await this.extractFileInfoFromZip(fileBuffer); // Load ZIP once

    let isDelta = false;
    let added = 0, removed = 0, modified = 0;

    if (previousVersionData) {
        isDelta = true;
        const prevFileMap = previousVersionData.individualFiles;
        const newFilePaths = new Set(newIndividualFileInfos.map(f => f.path));

        for (const newFile of newIndividualFileInfos) {
            const prevFile = prevFileMap[newFile.path];
            if (!prevFile) added++;
            else if (prevFile.hash !== newFile.hash) modified++;
        }
        for (const path in prevFileMap) {
            if (!newFilePaths.has(path)) removed++;
        }
        console.log(`[SERVICE_MODPACK_UPLOAD] Delta calculated for ${fileType}: Added ${added}, Removed ${removed}, Modified ${modified}.`);
    } else {
        added = newIndividualFileInfos.length; // All files are new if no previous version
        console.log(`[SERVICE_MODPACK_UPLOAD] No previous version found for ${fileType}. All ${added} files considered new.`);
    }

    // Transaction for DB inserts
    return await db.transaction(async (tx) => {
        const [versionFileEntry] = await tx
            .insert(ModpackVersionFilesTable)
            .values({
                modpackVersionId: modpackVersionId, type: fileType, hash: mainFileHash, isDelta,
                size: fileBuffer.length // Store size of the main ZIP
            })
            .returning();

        if (newIndividualFileInfos.length > 0) {
            // Upload individual files to S3 (if this strategy is kept)
            // This part is resource-intensive. Consider if storing individual files in S3 is truly necessary
            // if the main ZIP is already stored.
            const zip = await JSZip.loadAsync(fileBuffer); // Load ZIP once for all individual file extractions
            for (const fileInfo of newIndividualFileInfos) {
                const individualFileContent = await zip.file(fileInfo.path)?.async('nodebuffer');
                if (individualFileContent) {
                    const individualFileS3Key = this.getIndividualFileS3Key(modpackId, modpackVersionId, fileType, fileInfo.hash);
                    // console.log(`[SERVICE_MODPACK_UPLOAD] Saving individual file ${fileInfo.path} to S3: ${individualFileS3Key}`);
                    await this.saveFileToStorage(individualFileS3Key, individualFileContent, 'application/octet-stream', {
                        'file-hash': fileInfo.hash, 'original-path': fileInfo.path
                    });
                }
            }

            // Batch insert individual file metadata
            const individualFileValues = newIndividualFileInfos.map(f => ({
                modpackVersionFileId: versionFileEntry.id,
                path: f.path, hash: f.hash, size: f.size,
            }));
            await tx.insert(ModpackVersionIndividualFilesTable).values(individualFileValues);
            console.log(`[SERVICE_MODPACK_UPLOAD] Stored metadata for ${newIndividualFileInfos.length} individual files in DB.`);
        }

        await this._updateVersionManifestInternal(
            modpackId, modpackVersionId, fileType, mainFileHash, tx,
            false, undefined, modpackInfo, versionInfo
        );

        const totalSize = newIndividualFileInfos.reduce((sum, file) => sum + file.size, 0);
        return {
            versionFileId: versionFileEntry.id, isDelta, fileCount: newIndividualFileInfos.length, totalSize,
            addedFiles: added, removedFiles: removed, modifiedFiles: modified,
        };
    });
  }


  /**
   * Sube un archivo ZIP al modpack y procesa sus contenidos
   */
  public async uploadFile(
    userId: string, // For authorization checks (TODO)
    modpackId: string,
    modpackVersionId: string,
    fileType: FileType,
    fileBuffer: Buffer,
    reuseFromVersion?: string
  ): Promise<UploadResult> {
    console.log(`[SERVICE_MODPACK_UPLOAD] Uploading ${fileType} for modpack ${modpackId}, version ${modpackVersionId}. User: ${userId}`);
    const { modpack, version: modpackVersion } = await this._ensureModpackAndVersionExist(modpackId, modpackVersionId);

    // Authorization: await this.checkUploadPermission(userId, modpackId);
    // if (!canUpload) throw new Error("Forbidden");

    if (reuseFromVersion && (fileType === FileType.CONFIGS || fileType === FileType.RESOURCES)) {
      const reuseResult = await this._handleFileReuse(modpackId, modpackVersionId, fileType, reuseFromVersion);
      if (reuseResult) return reuseResult;
      // If reuseResult is null, it means reuse failed or wasn't applicable, proceed to normal upload.
    }

    const previousVersionData = await this.findPreviousVersionFile(modpackId, fileType);

    const modpackInfo = { name: modpack.name }; // Pass only needed data
    const versionInfo = { version: modpackVersion.version, mcVersion: modpackVersion.mcVersion, forgeVersion: modpackVersion.forgeVersion };

    return this._processAndStoreNewFile(
        modpackId, modpackVersionId, fileType, fileBuffer,
        modpackInfo, versionInfo, previousVersionData
    );
  }

  /**
   * Actualiza o crea el manifiesto de una versión de modpack (internal version using transaction)
   */
  private async _updateVersionManifestInternal(
    modpackId: string,
    versionId: string,
    fileType: FileType,
    fileHash: string,
    dbOrTx: typeof db | Parameters<Parameters<typeof db.transaction>[0]>[0], // Drizzle transaction or DB client
    isReused = false,
    reusedFromVersionId?: string,
    // Pass modpack and version details if already fetched to avoid re-querying
    modpackDetails?: { name: string },
    versionDetails?: { version: string, mcVersion: string, forgeVersion?: string | null }
  ): Promise<void> {
    console.log(`[SERVICE_MODPACK_UPLOAD] Updating manifest for modpack ${modpackId}, version ${versionId}, fileType ${fileType}.`);

    let modpackName = modpackDetails?.name;
    let versionString = versionDetails?.version;
    let mcVersionString = versionDetails?.mcVersion;
    let forgeVersionString = versionDetails?.forgeVersion;

    if (!modpackName || !versionString || !mcVersionString) {
        const versionData = await (dbOrTx || db).query.ModpackVersionsTable.findFirst({
            where: eq(ModpackVersionsTable.id, versionId),
            columns: { version: true, mcVersion: true, forgeVersion: true },
            with: { modpack: { columns: { name: true }}}
        });
        if (!versionData || !versionData.modpack) throw new Error(`Version ${versionId} or its modpack not found for manifest update.`);

        modpackName = versionData.modpack.name;
        versionString = versionData.version;
        mcVersionString = versionData.mcVersion;
        forgeVersionString = versionData.forgeVersion;
    }

    const manifestKey = `${modpackId}/${versionId}/manifest.json`;
    let manifest: ModpackManifest;

    try {
      const existingManifestBuffer = await this.getFile(manifestKey);
      manifest = JSON.parse(existingManifestBuffer.toString('utf-8'));
    } catch (error: any) {
      // If manifest doesn't exist or error fetching, create a new one.
      // Check if it's a "not found" type error from S3 before creating new.
      console.log(`[SERVICE_MODPACK_UPLOAD] Manifest ${manifestKey} not found or failed to fetch. Creating new one. Error: ${error.message}`);
      manifest = {
        name: modpackName!,
        version: versionString!,
        mcVersion: mcVersionString!,
        forgeVersion: forgeVersionString || undefined, // Handle null from DB
        files: {},
        reusedFrom: {}
      };
    }

    manifest.files[fileType] = fileHash;
    if (isReused && reusedFromVersionId) {
      manifest.reusedFrom = manifest.reusedFrom || {};
      manifest.reusedFrom[fileType] = reusedFromVersionId;
    } else if (manifest.reusedFrom && manifest.reusedFrom[fileType] && !isReused) {
      // If file is not reused but was previously marked as reused, clear that mark.
      delete manifest.reusedFrom[fileType];
    }

    console.log(`[SERVICE_MODPACK_UPLOAD] Saving updated manifest to S3: ${manifestKey}`);
    await this.saveFileToStorage(manifestKey, Buffer.from(JSON.stringify(manifest, null, 2)), 'application/json');
  }

  // Public wrapper for updateVersionManifest if needed to be called externally (not using a transaction)
  public async updateVersionManifest(
    modpackId: string, versionId: string, fileType: FileType, fileHash: string,
    isReused = false, reusedFromVersionId?: string
  ): Promise<void> {
    await this._updateVersionManifestInternal(modpackId, versionId, fileType, fileHash, db, isReused, reusedFromVersionId);
  }

  /**
   * Obtiene el manifiesto de una versión
   */
  public async getVersionManifest(modpackId: string, versionId: string): Promise<ModpackManifest | null> {
    // TODO: Implement getVersionManifest method
    return null;
  }
}

// Exportamos una instancia configurada del servicio
export const modpackFileService = new ModpackFileUploadService(
    process.env.R2_REGION || 'auto', // Default R2 region
    process.env.R2_BUCKET_NAME || '',
    process.env.R2_ENDPOINT // Optional endpoint for S3 compatible services
    // Credentials should be picked up from environment by S3Client if R2_ACCESS_KEY_ID and R2_SECRET_ACCESS_KEY are set
);